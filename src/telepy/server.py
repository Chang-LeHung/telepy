import io
import json
import logging
import sys
import threading
from collections import defaultdict
from collections.abc import Callable
from http import HTTPStatus
from http.server import BaseHTTPRequestHandler, HTTPServer
from typing import Any, Final
from urllib.parse import parse_qs, urlparse

try:
    from typing import override
except ImportError:
    # For Python < 3.12, use typing_extensions or create a no-op decorator
    try:
        from typing_extensions import override  # type: ignore # noqa: UP035
    except ImportError:
        # If typing_extensions is not available, create a no-op decorator
        def override(func):
            return func


from ._telepysys import __version__

GET: Final = "GET"
POST: Final = "POST"


class TelePyHandler(BaseHTTPRequestHandler):
    """
    All the following fileds are auto-generated by telepy.
    """

    routers: dict[str, dict[str, Callable[..., Any]]]
    app: "TelePyApp"
    server: HTTPServer

    def __init__(self, request, client_address, server) -> None:
        """
        Initializes a new request handler instance.

        Args:
            request: The client request object.
            client_address: The client address tuple (host, port).
            server: The server instance.
            log: Flag indicating whether to enable logging.
            logger: Logger instance for request logging.
        """
        super().__init__(request, client_address, server)
        self.telepy_headers: dict[str, str] = {}
        self.req: TelePyRequest
        self.resp: TelePyInterceptor
        self.interceptor: TelePyInterceptor
        self.log: bool
        self.logger: logging.Logger

    def before_request(self):
        """
        This method is called before the request is handled.
        """
        for intercetor in self.app._before_routers:
            intercetor(self.req, self.interceptor)
            if not self.interceptor.flow:
                return

    def after_request(self):
        """
        This method is called after the request is handled.
        """
        for resp_handler in self.app._after_routers:
            resp_handler(self.req, self.resp)
            if not self.resp.flow:
                return

    @override
    def handle_one_request(self):  # pragma: no cover
        """Handle a single HTTP request.

        You normally don't need to override this method; see the class
        __doc__ string for information on how to handle specific HTTP
        commands such as GET and POST.

        """
        try:
            self.raw_requestline = self.rfile.readline(65537)
            if len(self.raw_requestline) > 65536:
                self.requestline = ""
                self.request_version = ""
                self.command = ""
                self.send_error(HTTPStatus.REQUEST_URI_TOO_LONG)
                return
            if not self.raw_requestline:
                self.close_connection = True
                return
            if not self.parse_request():
                # An error code has been sent, just exit
                return
            mname = "do_" + self.command
            if not hasattr(self, mname):
                self.send_error(
                    HTTPStatus.NOT_IMPLEMENTED,
                    f"Unsupported method ({self.command!r})",
                )
                return
            method = getattr(self, mname)
            parsed_url = urlparse(self.path)
            query = parse_qs(parsed_url.query)
            self.req = TelePyRequest(
                app=self.app,
                headers=self.headers,
                query=query,
                url=parsed_url.path,
                method=self.command,
            )
            self.interceptor = TelePyInterceptor(
                status_code=HTTPStatus.OK.value, headers={}
            )
            self.resp = self.interceptor
            self.before_request()
            if self.interceptor.forward:
                method()
            self.interceptor.flow = True
            self.after_request()
            self._request_finished()
            self.wfile.flush()  # actually send the response if not already done.
        except TimeoutError as e:  # pragma: no cover
            # a read or a write timed out.  Discard this connection
            self.log_error("Request timed out: %r", e)
            self.close_connection = True
            return

    def _request_finished(self):
        for key, val in self.resp.headers.items():
            self.send_header(key, val)
        self.end_headers()
        self.wfile.write(self.resp.buf.getvalue())

    def do_GET(self):
        parsed_url = urlparse(self.path)
        path = parsed_url.path
        if path in self.routers[GET]:
            self.resp.start()
            self.routers[GET][path](self.req, self.resp)
            self.send_response(self.resp.status_code)
            self.resp.finish()
            return

        self.send_error_response(HTTPStatus.NOT_FOUND.value, HTTPStatus.NOT_FOUND.phrase)

    def do_POST(self):
        parsed_url = urlparse(self.path)

        # Validate request body size
        max_body_size = 10 * 1024 * 1024  # 10MB limit
        content_length = self.req.content_length
        if content_length > max_body_size:
            self.send_error_response(
                HTTPStatus.REQUEST_ENTITY_TOO_LARGE.value, "Request entity too large"
            )
            return

        path = parsed_url.path
        if path in self.routers[POST]:
            self.req.body = self.rfile.read(content_length)
            resp = self.resp
            resp.start()
            self.routers[POST][path](self.req, self.resp)
            self.send_response(self.resp.status_code)
            resp.finish()
            return
        self.send_error_response(HTTPStatus.NOT_FOUND.value, HTTPStatus.NOT_FOUND.phrase)

    def send_error_response(self, status_code: int, message: str):
        self.send_response(status_code)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        body = {
            "error": {
                "code": status_code,
                "message": message,
            }
        }
        self.wfile.write(json.dumps(body).encode())

    def log_message(self, format, *args):
        if self.log:
            self.logger.info(
                f"{self.client_address[0]} - - [{self.log_date_time_string()}] {format % args}"  # noqa: E501
            )

    @override
    def send_response(self, code, message=None):
        """Add the response header to the headers buffer and log the
        response code.

        Also send two standard headers with the server software
        version and the current date.

        """
        self.log_request(code)
        self.send_response_only(code, message)
        self.send_header("Server", f"TelePy Monitoring Server/{__version__}")
        self.send_header("Date", self.date_time_string())


class TelePyException(Exception):
    def __init__(self, message: str) -> None:
        super().__init__(message)


class TelePyRequest:
    def __init__(
        self,
        app: "TelePyApp",
        headers: dict[str, str],
        body: bytes | None = None,
        url: str = "/",
        query: dict[str, list[str]] | None = None,
        method: str = "GET",
    ):
        self.app = app
        self.headers = headers
        self.body = body
        self.url = url
        if query is None:
            query = {}
        self.query = query
        self.method = method
        self._json_data: Any | None = None
        self._json_error: str | None = None

    @property
    def json(self) -> Any:
        """Parse JSON data from request body."""
        if self._json_data is not None:
            return self._json_data
        if self._json_error is not None:
            raise json.JSONDecodeError(self._json_error, "", 0)

        if not self.body:
            return None

        try:
            self._json_data = json.loads(self.body.decode("utf-8"))
            return self._json_data
        except json.JSONDecodeError as e:
            self._json_error = str(e)
            raise

    @property
    def content_length(self) -> int:
        """Get content length from headers."""
        try:
            return int(self.headers.get("Content-Length", 0))
        except ValueError:
            return 0

    @property
    def content_type(self) -> str:
        """Get content type from headers."""
        return self.headers.get("Content-Type", "")


class TelePyResponseMixin:
    """
    Add lifecycle methods to TelePyResponse.
    """

    def start(self) -> None:
        """Call it before call the user's router."""
        pass

    def finish(self) -> None:
        """Call it after call the user's router."""
        pass


class TelePyResponse(TelePyResponseMixin):
    def __init__(self, status_code: int, headers: dict[str, str]) -> None:
        self.status_code = status_code
        self.headers = headers
        self.buf = io.BytesIO()
        self.close: bool = False

    def return_raw(self, data: bytes) -> None:
        self.buf.write(data)

    def return_str(self, data: str) -> None:
        self.headers["Content-Type"] = "text/plain; charset=utf-8"
        self.return_raw(data.encode())

    def return_json(self, data: Any) -> None:
        self.headers["Content-Type"] = "application/json; charset=utf-8"
        self.return_raw(json.dumps(data).encode())

    def finish(self):
        super().finish()
        if "Content-Length" not in self.headers:
            self.headers["Content-Length"] = str(len(self.buf.getvalue()))
        if "Content-Type" not in self.headers:
            self.headers["Content-Type"] = "text/plain; charset=utf-8"


class TelePyInterceptor(TelePyResponse):
    def __init__(self, status_code, headers) -> None:
        super().__init__(status_code, headers)
        self._forward: bool = True
        self._flow: bool = True

    @property
    def forward(self) -> bool:
        return self._forward

    @forward.setter
    def forward(self, value: bool):
        self._forward = value
        if not value:
            self._flow = False

    @property
    def flow(self) -> bool:
        return self._flow

    @flow.setter
    def flow(self, value: bool) -> None:
        self._flow = value


class TelePyApp:
    supported_methods = ("GET", "POST")

    def __init__(
        self,
        port: int = 8026,
        host: str = "127.0.0.1",
        filename: str | None = None,
        log: bool = True,
    ) -> None:
        self.port = port
        self.host = host
        self._close = False

        self._register_values: dict[str, Any] = dict()

        self._routers: dict[str, dict[str, Callable[..., Any]]] = defaultdict(dict)

        self._before_routers: list[Callable[..., Any]] = []
        self._after_routers: list[Callable[..., Any]] = []

        self._filename = filename
        self._log = log
        self.server: None | HTTPServer = None
        formatter = logging.Formatter("%(message)s")
        if self._log and self._filename is None:
            logger = logging.getLogger("http.server")
            logger.setLevel(logging.INFO)
            handler = logging.StreamHandler(sys.stdout)
            handler.setFormatter(formatter)
            logger.handlers = [handler]
            self.logger: logging.Logger | None = logger
        elif not self._log:
            self.logger = None
        elif self._filename is not None:
            self.logger = logging.getLogger("http.server")
            self.logger.setLevel(logging.INFO)
            fh = logging.FileHandler(self._filename)
            fh.setFormatter(formatter)
            self.logger.handlers = [fh]
        else:
            self.logger = None

    def register(self, name: str, value: Any) -> None:
        """
        Register a name-value pair in the registry.

        Args:
            name (str): The name to register.
            value (Any): The value associated with the name.

        Raises:
            KeyError: If the name is already registered.

        Note:
            This method ensures that each name is unique in the registry.
        """
        if name in self._register_values:
            raise KeyError(f"{name} already registered")
        self._register_values[name] = value

    def lookup(self, name: str) -> Any:
        return self._register_values.get(name)

    def route(
        self, path: str, method: str = "GET"
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]]:
        if method not in self.supported_methods:
            raise TelePyException(f"Method {method} is not supported")

        def decorator(func: Callable[..., Any]) -> Callable[..., Any]:
            self._routers[method.upper()][path] = func
            return func

        return decorator

    def run(self) -> None:
        clazz = type(
            "TelePyAppHandler",
            (TelePyHandler,),
            {
                "app": self,
                "routers": self._routers,
                "log": self._log,
                "logger": self.logger,
            },
        )
        self.server = HTTPServer((self.host, self.port), clazz)

        self.server.serve_forever()

    def register_interceptor(self, func: Callable[..., Any]):
        """Register an interceptor function to be called before routing.

        Args:
            func: A callable to be registered as an interceptor.

        Returns:
            The same function that was passed in, allowing decorator usage.
        """
        self._before_routers.append(func)
        return func

    def register_response_handler(self, func: Callable[..., Any]):
        """Register a response handler function to be called after routing.

        Args:
            func: A callable to be registered as a response handler.

        Returns:
            The registered function for potential decorator usage.
        """
        self._after_routers.append(func)
        return func

    def defered_shutdown(self):  # pragma: no cover
        """Asynchronously shuts down the server in a non-blocking manner
        by spawning a daemon thread.

        This allows the main thread to continue execution while the server
        shutdown is processed in the background. The daemon thread ensures
        it won't prevent program exit if still running.
        """

        def shutdown():
            self.server.shutdown()
            self._close = True

        t = threading.Thread(target=shutdown)
        t.daemon = True
        t.start()

    def close(self) -> None:
        if self.server is not None:
            self.server.server_close()

    def server_close(self) -> None:
        return self.close()

    def shutdown(self):  # pragma: no cover
        """Shuts down the server in a blocking manner."""
        if self.server is not None:
            self.server.shutdown()
        self._close = True

    @property
    def is_alive(self) -> bool:
        return not self._close

    @staticmethod
    def enable_address_reuse():
        """Enable address reuse for the server socket."""
        HTTPServer.allow_reuse_address = True

    @staticmethod
    def disable_address_reuse():
        """Disable address reuse for the server socket."""
        HTTPServer.allow_reuse_address = False
