import io
import json
import logging
import sys
import threading
from collections import defaultdict
from collections.abc import Callable
from http import HTTPStatus
from http.server import BaseHTTPRequestHandler, HTTPServer
from typing import Any, override
from urllib.parse import parse_qs, urlparse

from ._telepysys import __version__

logger = logging.getLogger("http.server")
logger.setLevel(logging.INFO)
handler = logging.StreamHandler(sys.stdout)
formatter = logging.Formatter("%(message)s")
handler.setFormatter(formatter)
logger.handlers = [handler]


class TelePyHandler(BaseHTTPRequestHandler):
    """
    All the following fileds are auto-generated by telepy.
    """

    routers: dict[str, dict[str, Callable[..., Any]]]
    app: "TelepyApp"
    server: HTTPServer

    def __init__(self, request, client_address, server) -> None:
        super().__init__(request, client_address, server)
        self.telepy_headers: dict[str, str] = {}
        self.req: TelePyRequest
        self.resp: TelePyInterceptor
        self.interceptor: TelePyInterceptor

    def before_request(self):
        """
        This method is called before the request is handled.
        """
        for intercetor in self.app.before_routers:
            intercetor(self.req, self.interceptor)
            if not self.interceptor.flow:
                return

    def after_request(self):
        """
        This method is called after the request is handled.
        """
        for resp_handler in self.app.after_routers:
            resp_handler(self.req, self.resp)
            if not self.resp.flow:
                return

    @override
    def handle_one_request(self):  # pragma: no cover
        """Handle a single HTTP request.

        You normally don't need to override this method; see the class
        __doc__ string for information on how to handle specific HTTP
        commands such as GET and POST.

        """
        try:
            self.raw_requestline = self.rfile.readline(65537)
            if len(self.raw_requestline) > 65536:
                self.requestline = ""
                self.request_version = ""
                self.command = ""
                self.send_error(HTTPStatus.REQUEST_URI_TOO_LONG)
                return
            if not self.raw_requestline:
                self.close_connection = True
                return
            if not self.parse_request():
                # An error code has been sent, just exit
                return
            mname = "do_" + self.command
            if not hasattr(self, mname):
                self.send_error(
                    HTTPStatus.NOT_IMPLEMENTED,
                    f"Unsupported method ({self.command!r})",
                )
                return
            method = getattr(self, mname)
            parsed_url = urlparse(self.path)
            query = parse_qs(parsed_url.query)
            self.req = TelePyRequest(
                app=self.app,
                headers=self.headers,
                query=query,
                url=parsed_url.path,
                method=self.command,
            )
            self.interceptor = TelePyInterceptor(
                status_code=HTTPStatus.OK.value, headers={}
            )
            self.resp = self.interceptor
            self.before_request()
            if self.interceptor.forward:
                method()
            self.interceptor.flow = True
            self.after_request()
            self._request_finished()
            self.wfile.flush()  # actually send the response if not already done.
        except TimeoutError as e:  # pragma: no cover
            # a read or a write timed out.  Discard this connection
            self.log_error("Request timed out: %r", e)
            self.close_connection = True
            return

    def _request_finished(self):
        print(f"{self.resp.headers = }")
        for key, val in self.resp.headers.items():
            self.send_header(key, val)
        self.end_headers()
        self.wfile.write(self.resp.buf.getvalue())

    def do_GET(self):
        parsed_url = urlparse(self.path)
        path = parsed_url.path
        if path in self.routers["GET"]:

            self.resp.start()
            self.routers["GET"][path](self.req, self.resp)
            self.send_response(self.resp.status_code)
            self.resp.finish()
            return

        self.send_error_response(
            HTTPStatus.NOT_FOUND.value, HTTPStatus.NOT_FOUND.phrase
        )

    def do_POST(self):
        parsed_url = urlparse(self.path)

        path = parsed_url.path
        if path in self.routers["POST"]:
            req = self.req
            resp = self.resp
            resp.start()
            self.routers["POST"][path](req, resp)
            resp.finish()
            return
        self.send_error_response(
            HTTPStatus.NOT_FOUND.value, HTTPStatus.NOT_FOUND.phrase
        )

    def send_error_response(self, status_code: int, message: str):
        self.send_response(status_code)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        body = {
            "error": {
                "code": status_code,
                "message": message,
            }
        }
        self.wfile.write(json.dumps(body).encode())

    def log_message(self, format, *args):
        logger.info(
            f"{self.client_address[0]} - - [{self.log_date_time_string()}] {format % args}"  # noqa: E501
        )

    @override
    def send_response(self, code, message=None):
        """Add the response header to the headers buffer and log the
        response code.

        Also send two standard headers with the server software
        version and the current date.

        """
        self.log_request(code)
        self.send_response_only(code, message)
        self.send_header("Server", f"TelePy Monitoring Server/{__version__}")
        self.send_header("Date", self.date_time_string())


class TelePyException(Exception):
    def __init__(self, message: str) -> None:
        super().__init__(message)


class TelePyRequest:
    def __init__(
        self,
        app: "TelepyApp",
        headers: dict[str, str],
        body: bytes | None = None,
        url: str = "/",
        query: dict[str, list[str]] | None = None,
        method: str = "GET",
    ):
        self.app = app
        self.headers = headers
        self.body = body
        self.url = url
        if query is None:
            query = {}
        self.query = query
        self.method = method


class TelePyResponseMixin:
    """
    Add lifecycle methods to TelePyResponse.
    """

    def start(self) -> None:
        """Call it before call the user's router."""
        pass

    def finish(self) -> None:
        """Call it after call the user's router."""
        pass


class TelePyResponse(TelePyResponseMixin):
    def __init__(self, status_code: int, headers: dict[str, str]) -> None:
        self.status_code = status_code
        self.headers = headers
        self.buf = io.BytesIO()
        self.close: bool = False

    def return_raw(self, data: bytes) -> None:
        self.buf.write(data)

    def return_str(self, data: str) -> None:
        self.headers["Content-Type"] = "text/plain; charset=utf-8"
        self.return_raw(data.encode())

    def return_json(self, data: Any) -> None:
        self.headers["Content-Type"] = "application/json; charset=utf-8"
        self.return_raw(json.dumps(data).encode())

    def finish(self):
        super().finish()
        if "Content-Length" not in self.headers:
            self.headers["Content-Length"] = str(len(self.buf.getvalue()))
        if "Content-Type" not in self.headers:
            self.headers["Content-Type"] = "text/plain; charset=utf-8"


class TelePyInterceptor(TelePyResponse):

    def __init__(self, status_code, headers) -> None:
        super().__init__(status_code, headers)
        self._forward: bool = True
        self._flow: bool = True

    @property
    def forward(self) -> bool:
        return self._forward

    @forward.setter
    def forward(self, value: bool):
        self._forward = value
        if not value:
            self._flow = False

    @property
    def flow(self) -> bool:
        return self._flow

    @flow.setter
    def flow(self, value: bool) -> None:
        self._flow = value


class TelepyApp:
    supported_methods = ("GET",)

    def __init__(
        self,
        port: int = 8026,
        host: str = "127.0.0.1",
    ) -> None:
        self.port = port
        self.host = host

        self.routers: dict[str, dict[str, Callable[..., Any]]] = defaultdict(dict)

        self.before_routers: list[Callable[..., Any]] = []
        self.after_routers: list[Callable[..., Any]] = []

    def route(
        self, path: str, method: str = "GET"
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]]:
        if method not in self.supported_methods:
            raise TelePyException(f"Method {method} is not supported")

        def decorator(func: Callable[..., Any]) -> Callable[..., Any]:
            self.routers[method.upper()][path] = func
            return func

        return decorator

    def run(self) -> None:
        clazz = type(
            "TelePyAppHandler", (TelePyHandler,), {"app": self, "routers": self.routers}
        )
        self.server = HTTPServer((self.host, self.port), clazz)

        self.server.serve_forever()

    def register_interceptor(self, func: Callable[..., Any]):
        """Register an interceptor function to be called before routing.

        Args:
            func: A callable to be registered as an interceptor.

        Returns:
            The same function that was passed in, allowing decorator usage.
        """
        self.before_routers.append(func)
        return func

    def register_response_handler(self, func: Callable[..., Any]):
        """Register a response handler function to be called after routing.

        Args:
            func: A callable to be registered as a response handler.

        Returns:
            The registered function for potential decorator usage.
        """
        self.after_routers.append(func)
        return func

    def defered_shutdown(self):
        """Asynchronously shuts down the server in a non-blocking manner
        by spawning a daemon thread.

        This allows the main thread to continue execution while the server
        shutdown is processed in the background. The daemon thread ensures
        it won't prevent program exit if still running.
        """

        t = threading.Thread(target=self.server.shutdown)
        t.daemon = True
        t.start()
